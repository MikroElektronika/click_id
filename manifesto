#!/usr/bin/env python

# Copyright (c) 2015-2016 Google, Inc.
# Copyright (c) 2015 Linaro, Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from __future__ import print_function

import argparse
import collections
try:
    import configparser
except ImportError:
    import ConfigParser as configparser
import os.path
import struct
import sys

### Exception management
class Error(Exception):
    def __init__(self, msg=''):
        self.message = msg
        super(Error, self).__init__(msg)

    def __repr__(self):
        return self.message

    __str__ = __repr__

### Error and warning management

def print_stderr(*objs):
    print(*objs, file=sys.stderr)

class warnings(object):
    silent = False

    @staticmethod
    def warn(msg):
        if not warnings.silent:
            print_stderr("Warning: " + msg)

### Manifest internal representation

class Manifest(object):
    """
    The Manifest is the composition of a Manifest Header and a set of
    Descriptors
    """

    def __init__(self):
        self.header = None
        self.descriptors = []

        self.string_descs = {}
        self.device_descs = {}
        self.property_descs = {}

    def add_header(self, hdr):
        self.header = hdr

    def __add_desc(self, desc):
        self.descriptors.append(desc)

    def __add_desc_dict(self, dict_, desc):
        if desc.id_ in dict_:
            raise Error("duplicated 'id' for descriptors '{}' and '{}'"
                    .format(desc, dict_[desc.id_]))
        dict_[desc.id_] = desc

    def add_string_desc(self, desc):
        self.__add_desc_dict(self.string_descs, desc)
        self.__add_desc(desc)
    
    def add_property_desc(self, desc):
        self.__add_desc_dict(self.property_descs, desc)
        self.__add_desc(desc)

    def add_device_desc(self, desc):
        self.__add_desc_dict(self.device_descs, desc)
        self.__add_desc(desc)

class ManifestHeader(object):
    MB_VERSION_MAJOR = 0
    MB_VERSION_MINOR = 1

    def __init__(self, major, minor, props):
        if (major != ManifestHeader.MB_VERSION_MAJOR or
                minor != ManifestHeader.MB_VERSION_MINOR):
            raise Error("invalid '[{}]' format version '{}.{}'"
                    "(only supports '{}.{}')".format(
                        MnfsParser.MNFS_HEADER, major, minor,
                        ManifestHeader.MB_VERSION_MAJOR,
                        ManifestHeader.MB_VERSION_MINOR))
        self.major = major
        self.minor = minor
        self.click_string_id = props[0]
        self.num_devices = props[1]
        self.rst_gpio = props[2]
        self.pwm_gpio = props[3]
        self.int_gpio = props[4]

    def __str__(self):
        r = "[{}]\n".format(MnfsParser.MNFS_HEADER)
        r += "version-major = {}\n".format(self.major)
        r += "version-minor = {}\n".format(self.minor)
        r += "click-string-id = {}\n".format(self.minor)
        r += "num-devices = {}\n".format(self.minor)
        r += "reset-gpio-state = {}\n".format(self.minor)
        r += "pwm-gpio-state = {}\n".format(self.minor)
        r += "int-gpio-state = {}\n".format(self.minor)
        return r

class Descriptor(object):
    def __init__(self, section, used = False):
        self.section = section
        self.used = used

class StringDescriptor(Descriptor):
    def __init__(self, id_, string, section):
        super(StringDescriptor, self).__init__(section)
        if id_ == 0:
            raise Error("invalid id for '[{}]' (cannot be 0)".format(section))
        self.id_ = id_
        self.string = string
        self._parent = None

    @property
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, desc):
        if self._parent is not None:
            raise Error("multiple references to [{}]".format(self.section))
        self.used = True
        self._parent = desc

    def __str__(self):
        r = ""
        r += "[{} {:#x}]\n".format(MnfsParser.STRING_DESC, self.id_)
        r += "string = {}\n".format(self.string)
        return r

class PropertyDescriptor(Descriptor):
    def __init__(self, id_, name_stringid, typ, value, section):
        super(PropertyDescriptor, self).__init__(section)
        if id_ == 0:
            raise Error("invalid id for '[{}]' (cannot be 0)".format(section))
        self.id_ = id_
        self.name_stringid = name_stringid
        self.typ = typ
        self.value = value
        self._parent = None

    @property
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, desc):
        if self._parent is not None:
            raise Error("multiple references to [{}]".format(self.section))
        self.used = True
        self._parent = desc

    def __str__(self):
        r = ""
        r += "[{} {:#x}]\n".format(MnfsParser.PROPERTY_DESC, self.id_)
        r += "name-string-id = {}\n".format(self.name_stringid)
        r += "type = {}\n".format(self.typ)
        r += "value = {}\n".format(self.value)
        return r

class DeviceDescriptor(Descriptor):
    device_protocol = {
            0x01: 'SPI',
            0x02: 'I2C',
            0x03: 'UART',
            0x04: 'SPI_GPIO_CS',
            0x05: 'I2C_MUX'
            }

    def __init__(self, id_, props, section):
        super(DeviceDescriptor, self).__init__(section)
        self.id_ = id_        
        self.driver_string_id = props[0]
        self.num_properties = props[1]
        self.protocol = props[2]
        self.reg = props[3]
        self.cs_gpio = props[4]
        self.irq = props[5]
        self.irq_type = props[6]
        self.max_speed_hz = props[7]
        self.mode = props[8]
        self.num_gpio_res = props[9]
        self.prop_link = props[10]
        self.gpio_link = props[11]

    @property
    def protocol_name(self):
        try:
            return self.device_protocol[self.protocol]
        except KeyError:
            return "Reserved"

    def __str__(self):
        r = "; '{}' Protocol on Device {}\n".format(self.protocol_name, self.id_)
        r += "[{} {:#x}]\n".format(MnfsParser.DEVICE_DESC, self.id_)
        r += "driver-string-id = {:#x}\n".format(self.driver_string_id)
        r += "num-properties = {:#x}\n".format(self.num_properties)
        r += "protocol = {:#x}\n".format(self.protocol)
        r += "reg = {:#x}\n".format(self.reg)
        r += "cs-gpio = {:#x}\n".format(self.cs_gpio)
        r += "irq = {:#x}\n".format(self.irq)
        r += "irq-type = {:#x}\n".format(self.irq_type)
        r += "max-speed-hz = {:#x}\n".format(self.max_speed_hz)
        r += "mode = {:#x}\n".format(self.mode)
        r += "num-gpio-res = {:#x}\n".format(self.num_gpio_res)
        r += "prop-link = {:#x}\n".format(self.prop_link)
        r += "gpio-link = {:#x}\n".format(self.gpio_link)
        return r

### File parsers
class MnfsParser(object):

    # strings
    MNFS_HEADER         = 'manifest-header'
    MNFS_HEADER_VMAJ    = 'version-major'
    MNFS_HEADER_VMIN    = 'version-minor'
    MNFS_HEADER_CLICK_STRING_ID = 'click-string-id'
    MNFS_HEADER_NUM_DEVICES = 'num-devices'
    MNFS_HEADER_RESET_GPIO_STATE = 'reset-gpio-state'
    MNFS_HEADER_PWM_GPIO_STATE = 'pwm-gpio-state'
    MNFS_HEADER_INT_GPIO_STATE = 'int-gpio-state'
    STRING_DESC         = 'string-descriptor'
    STRING_DESC_STRING  = 'string'
    DEVICE_DESC         = 'device-descriptor'
    DEVICE_DESC_DRIVER_STRING_ID   = 'driver-string-id'
    DEVICE_DESC_NUM_PROPERTIES   = 'num-properties'
    DEVICE_DESC_MAX_SPEED_HZ   = 'max-speed-hz'
    DEVICE_DESC_MODE   = 'mode'
    DEVICE_DESC_NUM_GPIO_RESOURCES   = 'num-gpio-resources'
    DEVICE_DESC_PROTOCOL   = 'protocol'
    DEVICE_DESC_REG   = 'reg'
    DEVICE_DESC_CS_GPIO   = 'cs-gpio'
    DEVICE_DESC_IRQ   = 'irq'
    DEVICE_DESC_IRQ_TYPE   = 'irq-type'
    DEVICE_DESC_PROP_LINK   = 'prop-link'
    DEVICE_DESC_GPIO_LINK   = 'gpio-link'
    PROPERTY_DESC         = 'property-descriptor'
    PROPERTY_DESC_NAME_STRING_ID  = 'name-string-id'
    PROPERTY_DESC_TYPE  = 'type'
    PROPERTY_DESC_VALUE  = 'value'

    # sizes
    MNFS_HEADER_VERSION_SIZE    = 1
    ID_DESC_SIZE                = 1
    MAX_SPEED_DESC_SIZE         = 4
    STRING_DESC_STRING_SIZE     = 255
    PROP_DESC_VALUE_SIZE     = 255

    def __init__(self):
        pass

    def __check_int(self, int_val, num_bytes):
        min_ = 0
        max_ = 2**(8 * num_bytes) - 1
        if int_val < min_ or int_val > max_:
            raise ValueError("out of range ([{}:{}])".format(min_, max_))
        return int_val

    def __parse_id(self, section, num_bytes):
        try:
            # Accepted syntax is '<descriptor-type> <id>'
            # and id can be double-quoted.
            id_ = int(section.split()[1].strip('"'), base=0)
            return self.__check_int(id_, num_bytes)
        except IndexError:
            raise Error("missing id value in '[{}]'".format(section))
        except ValueError as e:
            raise Error("invalid id value in '[{}]': {}"
                    .format(section, str(e)))

    def __get_option(self, cfg_parser, section, option_name):
        try:
            return cfg_parser.get(section, option_name)
        except configparser.NoOptionError as e:
            raise Error("missing field '{}' in '[{}]'".format(option_name,
                section))

    def __get_int_option(self, cfg_parser, section, option_name, num_bytes):
        try:
            str_opt = self.__get_option(cfg_parser, section, option_name)
            int_opt =  int(str_opt, base=0)
            return self.__check_int(int_opt, num_bytes)
        except ValueError as e:
            raise Error("invalid value '{}' for field '{}' in '[{}]': {}"
                    .format(int_opt, option_name, section, str(e)))

    def __get_str_option(self, cfg_parser, section, option_name, max_):
        str_opt = self.__get_option(cfg_parser, section, option_name)
        if len(str_opt) > max_:
            raise Error("string '{}' for field '{}' in '[{}]' "
            "is too long (maximum is {})".format(str_opt, option_name, section,
                max_))
        return str_opt

    def parse_file(self, mnfs_file):
        # force an OrderedDict to get deterministic output even on Python 2.6.
        cfg_parser = configparser.ConfigParser(dict_type=collections.OrderedDict)

        with open(mnfs_file, 'r') as f:
            cfg_parser.readfp(f)

        manifest = Manifest()

        # the error reporting in this function is purely syntaxical

        for section in cfg_parser.sections():
            if section != section.strip():
                raise Error("invalid spaces in '[{}]'".format(section))

            if section == MnfsParser.MNFS_HEADER:
                vmaj = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_VMAJ,
                        MnfsParser.MNFS_HEADER_VERSION_SIZE)
                vmin = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_VMIN,
                        MnfsParser.MNFS_HEADER_VERSION_SIZE)
                clickstr = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_CLICK_STRING_ID,
                        MnfsParser.ID_DESC_SIZE)
                numdev = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_NUM_DEVICES,
                        MnfsParser.ID_DESC_SIZE)
                rstgpio = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_RESET_GPIO_STATE,
                        MnfsParser.ID_DESC_SIZE)
                pwmgpio = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_PWM_GPIO_STATE,
                        MnfsParser.ID_DESC_SIZE)
                intgpio = self.__get_int_option(cfg_parser, section,
                        MnfsParser.MNFS_HEADER_INT_GPIO_STATE,
                        MnfsParser.ID_DESC_SIZE)
                props = [clickstr, numdev, rstgpio, pwmgpio, intgpio]
                header = ManifestHeader(vmaj, vmin, props)
                manifest.add_header(header)

            elif section.split()[0] == MnfsParser.STRING_DESC:
                id_ = self.__parse_id(section, MnfsParser.ID_DESC_SIZE)
                str_ = self.__get_str_option(cfg_parser, section,
                        MnfsParser.STRING_DESC_STRING,
                        MnfsParser.STRING_DESC_STRING_SIZE)

                string = StringDescriptor(id_, str_, section)
                manifest.add_string_desc(string)
            
            elif section.split()[0] == MnfsParser.PROPERTY_DESC:
                id_ = self.__parse_id(section, MnfsParser.ID_DESC_SIZE)
                name_stringid = self.__get_int_option(cfg_parser, section,
                        MnfsParser.PROPERTY_DESC_NAME_STRING_ID,
                        MnfsParser.ID_DESC_SIZE)
                typ = self.__get_int_option(cfg_parser, section,
                        MnfsParser.PROPERTY_DESC_TYPE,
                        MnfsParser.ID_DESC_SIZE)
                value = self.__get_str_option(cfg_parser, section,
                        MnfsParser.PROPERTY_DESC_VALUE,
                        MnfsParser.PROP_DESC_VALUE_SIZE)
                value = list(map(int,value.split(" ")))
                prop = PropertyDescriptor(id_, name_stringid, typ, value, section)
                manifest.add_property_desc(prop)

            elif section.split()[0] == MnfsParser.DEVICE_DESC:
                id_ = self.__parse_id(section, MnfsParser.ID_DESC_SIZE)
                driverstr = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_DRIVER_STRING_ID,
                        MnfsParser.ID_DESC_SIZE)
                numprop = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_NUM_PROPERTIES,
                        MnfsParser.ID_DESC_SIZE)
                protocol = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_PROTOCOL,
                        MnfsParser.ID_DESC_SIZE)
                if(protocol == 1 or protocol == 4):
                    maxspeedhz = self.__get_int_option(cfg_parser, section,
                            MnfsParser.DEVICE_DESC_MAX_SPEED_HZ,
                            MnfsParser.MAX_SPEED_DESC_SIZE)
                    mode = self.__get_int_option(cfg_parser, section,
                            MnfsParser.DEVICE_DESC_MODE,
                            MnfsParser.ID_DESC_SIZE)                    
                    csgpio = self.__get_int_option(cfg_parser, section,
                            MnfsParser.DEVICE_DESC_CS_GPIO,
                            MnfsParser.ID_DESC_SIZE)
                else:
                    maxspeedhz=0
                    csgpio=0
                    mode=0
                numgpio = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_NUM_GPIO_RESOURCES,
                        MnfsParser.ID_DESC_SIZE)
                reg = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_REG,
                        MnfsParser.ID_DESC_SIZE)
                irq = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_IRQ,
                        MnfsParser.ID_DESC_SIZE)
                irq_type = self.__get_int_option(cfg_parser, section,
                        MnfsParser.DEVICE_DESC_IRQ_TYPE,
                        MnfsParser.ID_DESC_SIZE)
                if (numprop > 0):      
                    prop_link = self.__get_int_option(cfg_parser, section,
                            MnfsParser.DEVICE_DESC_PROP_LINK,
                            MnfsParser.ID_DESC_SIZE)
                else:
                    prop_link = 0
                if (numgpio > 0):
                    gpio_link = self.__get_int_option(cfg_parser, section,
                            MnfsParser.DEVICE_DESC_GPIO_LINK,
                            MnfsParser.ID_DESC_SIZE)
                else:
                    gpio_link = 0          
                props = [driverstr, numprop, protocol, reg, csgpio, irq, irq_type, \
                     maxspeedhz, mode, numgpio, prop_link, gpio_link]
                device = DeviceDescriptor(id_, props, section)
                manifest.add_device_desc(device)
            else:
                raise Error("invalid descriptor '[{}]'".format(section))

        return manifest

### Generators

class MnfbGenerator(object):

    # types
    STRING_DESC_TYPE = 0x01
    PROP_DESC_TYPE = 0x02
    DEVICE_DESC_TYPE    = 0x03

    # sizes
    MNFS_MAX_SIZE           = 0xffff
    MNFS_HEADER_SIZE        = 0xc
    BASE_DESC_SIZE          = 0x4
    DEVICE_DESC_SIZE     = BASE_DESC_SIZE + 0x10
    STRING_DESC_BASE_SIZE   = BASE_DESC_SIZE + 0x2
    PROP_DESC_BASE_SIZE   = BASE_DESC_SIZE + 0x4

    STRING_MAX_SIZE         = 0xff
    STRING_DESC_MAX_SIZE    = STRING_DESC_BASE_SIZE + STRING_MAX_SIZE 

    PROP_VALUE_SIZE = {
            0x00: 1,
            0x01: 1,
            0x02: 1,
            0x03: 2,
            0x04: 4,
            0x05: 8
            }

    # formatting
    MNFS_HEADER_FMT         = '<HBBBBBBBxxx'
    BASE_DESC_FMT           = '<HBx'
    DEVICE_DESC_FMT      = BASE_DESC_FMT + 'BBBBLBBBBBBBB'
    STRING_DESC_BASE_FMT    = BASE_DESC_FMT + 'BB'
    PROP_DESC_BASE_FMT    = BASE_DESC_FMT + 'BBBB'
    
    PROP_VALUE_DESC_FMT = {
            0x00: 'B',
            0x01: 'B',
            0x02: 'B',
            0x03: 'H',
            0x04: 'L',
            0x05: 'Q'
            }

    def __init__(self):
        self.mnfb = bytearray(MnfbGenerator.MNFS_MAX_SIZE)
        self.offset = MnfbGenerator.MNFS_HEADER_SIZE

    def __inc_offset(self, inc):
        self.offset += inc
        assert self.offset % 4 == 0, self.offset
        if self.offset >= MnfbGenerator.MNFS_MAX_SIZE:
            raise Error("output manifest binary exceeds maximum size {:#x}"
                    .format(MnfbGenerator.MNFS_MAX_SIZE))

    def __pack_header(self, hdr):
        struct.pack_into(MnfbGenerator.MNFS_HEADER_FMT,
                self.mnfb, 0, self.offset, hdr.major, hdr.minor, hdr.click_string_id, \
                    hdr.num_devices, hdr.rst_gpio, hdr.pwm_gpio, hdr.int_gpio)

    def __pack_desc(self, desc_fmt, desc_size, desc_type, *args):
        struct.pack_into(desc_fmt, self.mnfb, self.offset, desc_size, desc_type,
                *args)
        self.__inc_offset(desc_size)

    def __pack_device_desc(self, desc):
        self.__pack_desc(MnfbGenerator.DEVICE_DESC_FMT, MnfbGenerator.DEVICE_DESC_SIZE, \
                MnfbGenerator.DEVICE_DESC_TYPE, desc.id_, desc.driver_string_id, \
                desc.num_properties, desc.protocol, desc.max_speed_hz, desc.reg, desc.mode, \
                 desc.num_gpio_res, desc.cs_gpio, desc.irq, desc.irq_type, desc.prop_link, desc.gpio_link)

    def __string_desc_size(self, string):
        base_size = MnfbGenerator.STRING_DESC_BASE_SIZE + len(string)
        mod = base_size % 4
        pad_bytes = 4 - mod if mod else 0
        return base_size + pad_bytes

    def __string_desc_fmt(self, string):
        return "{}{}s".format(MnfbGenerator.STRING_DESC_BASE_FMT, len(string))

    def __pack_string_desc(self, desc):
        string_desc_size = self.__string_desc_size(desc.string)
        assert string_desc_size <= MnfbGenerator.STRING_DESC_MAX_SIZE, \
                ("string descriptor too long ({}[...])"
                        .format(desc.string[:MnfbGenerator.STRING_MAX_SIZE]))
        string_desc_fmt = self.__string_desc_fmt(desc.string)
        self.__pack_desc(string_desc_fmt, string_desc_size,
                MnfbGenerator.STRING_DESC_TYPE,
                len(desc.string), desc.id_, desc.string.encode("utf-8"))

    def __property_desc_size(self, typ, value):
        base_size = MnfbGenerator.PROP_DESC_BASE_SIZE + len(value)*MnfbGenerator.PROP_VALUE_SIZE[typ]
        mod = base_size % 4
        pad_bytes = 4 - mod if mod else 0
        return base_size + pad_bytes

    def __property_desc_fmt(self, typ, value):
        print("{}{}".format(MnfbGenerator.PROP_DESC_BASE_FMT, len(value)*(MnfbGenerator.PROP_VALUE_DESC_FMT[typ])))
        return "{}{}".format(MnfbGenerator.PROP_DESC_BASE_FMT, MnfbGenerator.PROP_VALUE_DESC_FMT[typ]*len(value))

    def __pack_property_desc(self, desc):
        prop_desc_size = self.__property_desc_size(desc.typ, desc.value)
        prop_desc_fmt = self.__property_desc_fmt(desc.typ, desc.value)
        vals = desc.value
        self.__pack_desc(prop_desc_fmt, prop_desc_size,
                MnfbGenerator.PROP_DESC_TYPE,
                len(desc.value), desc.id_, desc.name_stringid, desc.typ, *vals)

    def generate(self, manifest):
        # pack all the descriptors in order of their definition in the mnfs
        for desc in manifest.descriptors:
            if isinstance(desc, DeviceDescriptor):
                self.__pack_device_desc(desc)
            elif isinstance(desc, StringDescriptor):
                self.__pack_string_desc(desc)
            elif isinstance(desc, PropertyDescriptor):
                self.__pack_property_desc(desc)
            else:
                assert isinstance(desc, Descriptor), desc

        # save the header for last when we know the size of the whole structure
        self.__pack_header(manifest.header)

    def __get_mnfb(self):
        return self.mnfb[:self.offset]

    def write_file(self, mnfb_file):
        try:
            if mnfb_file == "stdout":
                sys.stdout.write(self.__get_mnfb())
            else:
                with open(mnfb_file, 'wb') as f:
                    f.write(self.__get_mnfb())
        except IOError as e:
            raise Error("can't write manifest binary '{}': {}"
                    .format(self.mnfb, str(e)))

### Command line arguments
def get_args():
    parser = argparse.ArgumentParser()

    parser.add_argument('infile',
            help='specify an input manifest file')

    return parser.parse_args()

def main():
    args = get_args()
    warnings.silent = False   
    parser = MnfsParser()
    manifest = parser.parse_file(args.infile)
    mnfb_gen = MnfbGenerator()
    mnfb_gen.generate(manifest)
    mnfb_gen.write_file((args.infile).replace(".mnfs", ".mnfb"))

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print_stderr("Error: {}".format(e))
        sys.exit(1)
